(** $Id$
	Description: Higher-order recursion scheme
	Author:		William Blum
**)

open Type
open Lnf

(****** Data-types ******)

type alphabet = (ident * typ) list;;

(* applicative term *)
type appterm = Nt of nonterminal | Tm of terminal | Var of ident | App of appterm * appterm;;

(* Recursion scheme *)
type rule = nonterminal * ident list * appterm;;
type recscheme = { nonterminals : alphabet;
				   sigma : alphabet;
				   rules : rule list;
				   rs_path_validator : terminal list -> bool * string } ;;
 (** The path validator is a function that checks whether a given path (list of terminals)
    generated by the recscheme satisfies the desired specification. It returns a pair [(v,c)] where [v] tells 
    whether the validation is successful and [c] is a certificate of the validation (a string message) **)
 



let string_of_appterm term :string= 
  let rec aux term = 
     match term with
  	  Tm(f) -> f
	| Nt(nt) -> nt
	| Var(x) -> x
	| App(l,(App(_) as r)) -> (aux l)^" ("^(aux  r)^")"
	| App(l,r) -> (aux l)^" "^(aux  r)
  in aux term
;;
let print_appterm term = print_string (string_of_appterm term);;


let string_of_rule rs ((nt,para,appterm):rule) = 
    nt^" "^(List.fold_left (function acc -> function p -> acc^p^" ") "" para)^"= "^(string_of_appterm appterm)^Common.eol
;;
let print_rule rs r = print_string (string_of_rule rs r);;

let string_of_rs rs =
    "Terminals:"^Common.eol^(string_of_alphabet rs.sigma)^
    "Non-terminals:"^Common.eol^(string_of_alphabet rs.nonterminals)^
    "Rules:"^Common.eol^(List.fold_left (function acc -> function r -> acc^(string_of_rule rs r)) "" rs.rules)
;;
let print_rs rs = print_string (string_of_rs rs);;


exception Type_check_error;;
exception Wrong_variable_name of ident;;
exception Wrong_terminal_name of ident;;
exception Wrong_nonterminal_name of ident;;

(* return the type of a terminal *)
let terminal_type rs f =
    try 
        List.assoc f rs.sigma
    with Not_found -> raise (Wrong_terminal_name f)
;;

(* return the type of a non-terminal *)
let nonterminal_type rs nt =
  try 
    List.assoc nt rs.nonterminals
  with Not_found -> raise (Wrong_nonterminal_name nt)
;;



(** Check that rs is a well-defined recursion scheme.
    @param rs the recursion scheme
    @return a list of error descriptions or an empty list if the recscheme passed the check.
    **)
let rs_check rs =
  let errorlst = ref [] in
  
  let adderror msg = errorlst:= msg::!errorlst in
  
  (* - parameters' names must be disjoint from terminals' names
     - appterm must be well-typed and para must be a superset of fv(appterm)
     - appterm must be of ground type
  *)
  let check_eq ((nt,para,appterm) as eq) =
    let partypelst = create_param_typ_list para (nonterminal_type rs nt) in
    let var_type x =  List.assoc x partypelst in
    let rec typecheck_term = function
          Tm(f) -> terminal_type rs f
        | Nt(nt) -> nonterminal_type rs nt
        | Var(x) -> if List.exists (function m -> m=x) para then
                      var_type x
                    else
                      raise (Wrong_variable_name x);
        | App(a,b) -> match (typecheck_term a), (typecheck_term b) with
                       Ar(tl,tr), tb when tl=tb ->  tr
                      |  _ -> raise Type_check_error;
    in
    (* ensures that the non-terminal name is defined *)
    let _ = nonterminal_type rs nt in

    (* check that the parameters names do not clash with terminals names *)
    let _ = List.exists (function p-> 
            (List.exists (function (a,t)-> 
                if a=p then
                  begin
                    adderror ("Parameter name "^p^" conflicts with a terminal name in "^(string_of_rule rs eq));
                  end;
                a=p) rs.sigma)) para in
    
    try if (typecheck_term appterm) <> Gr then
            adderror ("RHS is not of ground type in "^(string_of_rule rs eq));
    with 
          Wrong_variable_name(x) ->
            adderror ("Undefined variable '"^x^"' in RHS of "^(string_of_rule rs eq)) ;
        | Wrong_terminal_name(x) ->
            adderror ("Undefined terminal '"^x^"' in RHS of "^(string_of_rule rs eq)) ;
        | Wrong_nonterminal_name(x) ->
            adderror ("Undefined non-terminal '"^x^"' in RHS of "^(string_of_rule rs eq)) ;
        | Type_check_error ->
            adderror ("Type-checking error in RHS of "^(string_of_rule rs eq));
in
	(* Check all the rules *)
    List.iter check_eq rs.rules;

	(* Check that for each declared non non-terminal there is a corresponding rewriting rule *)
	List.iter (function nt,_ -> if not (List.exists (function nt2,_,_ -> nt2 = nt)  rs.rules ) then
	                            adderror ("There is no rewriting rule for the non-terminal "^nt)
	        ) rs.nonterminals;
	
	(* Check determinacy, i.e. there must be exactly one rule per non-terminal *)
	if List.length rs.rules > List.length rs.nonterminals then
	    adderror "The recursion must be deterministic! Make sure that there is exactly one rule per non-terminal";
    
	(* Check that the name (i.e. the non-terminal) of the first rule is of ground type *)
	if (List.length rs.rules) > 0 then
	begin
		match (List.hd rs.rules) with
			_,[],_ -> ()
		|	_ -> adderror "The LHS of the first rule must be of ground type (i.e. no parameter)!";
 	end;
				 
    !errorlst
;;


(** Decompose an term 'op e1 .... ek' into its constituents parts. 
   @return a pair (op,operands) where op is the operator (a terminal, variable or non-terminal) and
    operands is the list of operands terms. **)
let rec applicative_decomposition t = match t with
 Tm(_) | Var(_) | Nt(_) -> t,[]
 | App(a,b) -> let op,oper = applicative_decomposition a in op,oper@[b]
;;

(* Perform a reduction on the applicative term appterm (which must not contain any free variable) *)
let step_reduce rs appterm = 
  let substitute nt operands = 
    let _,parms,rhs = List.find (function rname,_,_ -> rname=nt) rs.rules in
      (* Check that we have the right number of operands (we only reduce full applications to non-terminals) *)
      if List.length parms = List.length operands then	
	let substlst = List.combine parms operands in
	let rec subst term = match term with
	    Tm(_) | Nt(_) -> term
	  | App(l,r) -> App((subst l), (subst r))
	  | Var(x)  -> try List.assoc x substlst
	    with Not_found -> term
	in
	  subst rhs
      else
	failwith ("Error: partial application to the terminal "^nt^".")
  in
    
  (* Look for the outermost reduction context in appterm, and if there is one perform the reduction.
     A reduction context is of the form C[_] where the hole contains a term of the form X t1 ... tn for some nonterminal X.
     
     The function takes two parameters:
     -appterm: the term in which we look for a context. 
     Let us assume that it is of the form T0 T1 T2 ... Tq where T0 is not an application.
     -operands: a list of operands terms that are applied to appterm (this parameter is used to 
     collect the list of parameters as we approach the operator node in the AST so that the parameters list
     is available when we reach the operator node and so we can perform the substitution)
     
     The function returns a triple: (found,outer,term) where
     If found=true then a reduction context has been found in appterm
     and 'term' contains the reducted term. 'outer' is set to true iff 
     the outermost redex-context is exactly the outermost application
     i.e. the context is C[_] = _ (and therefore C[appterm] = appterm)
     and Op is a non-terminal.
     
     If found=false then 'term' contains appterm and 'outer' has no meaning.
  *)
  let rec findredcontext_and_substitute appterm operands =
    match appterm with
	Tm(_) -> false,false,appterm
      | Var(_) -> failwith "Trying to reduce an open term!";
      | Nt(nt) -> true,true,(substitute nt operands)
      | App(t0_tqminusone,tq) -> 			
	  let f,o,t = findredcontext_and_substitute t0_tqminusone (tq::operands) in
	    if f then (* a context was found (and reduced) *)
	      true,o,
	  ( (* the outermost redex is exaclty the outermost application appterm = T0 T1 ... Tq *)
            if o then t 
	      (* the outermost context lies somewhere inside T0 or T1 or ... T_(q-1) *)
	    else App(t,tq)
	  )
	    else (* no context found: *)
	      (* then look for a context in the operand T_q *)
	      let f,o,t = findredcontext_and_substitute tq [] in
		f,false,App(t0_tqminusone, t)
  in
  let f,_,red = findredcontext_and_substitute appterm [] in
    f,red
;;

(* Perform an OI-derivation of the recursion scheme rs *)
let oi_derivation rs =

  let t = ref (Nt("S")) in 
    print_newline(); print_appterm !t;  print_newline();
    while (input_line stdin) <> "q" do
      let red,tred = step_reduce rs !t in
	t := tred;	
	
	print_appterm !t; print_newline(); print_newline();
    done;
;;

(** Return the type of an applicative term (assume that the term is well-typed) 
   @param fvtypes gives the types of the free variable in the term: a list of pair (var,typ) where 'typ' is the type of the variable 'var'.
**)
let rec appterm_type rs fvtypes = function
    Tm(f) -> terminal_type rs f
  | Nt(nt) -> nonterminal_type rs nt
  | Var(x) -> List.assoc x fvtypes
  | App(a,_) -> match appterm_type rs fvtypes a with 
                  Gr -> failwith "Term is not well-typed: operator of ground type!"
                | Ar(_,r) -> r
;;

(* return the order of an appterm *)
(***** unused 
let appterm_order rs fvtypes t = typeorder (appterm_type rs fvtypes t);;
*)




(** [get_parameter_type rs x] returns the type of the formal parameter [x].
    (Recall that the formal parameter names of the grammar equation are required to be disjoint,
    hence there is at most one equation that uses a given parameter) **)
let get_parameter_type rs x = 
  (* find the equation that uses the parameter x *)
  try 
      let (nt,parms,_) = List.find (function (_,parms,_) -> List.mem x parms) rs.rules
      in
        let rec get_param_type parms typ = match parms,typ with
          | [],Gr -> failwith "get_parameter_type: ground-type terminal!"
          | p::_, Ar(l,_) when p = x -> l
          | _::q, Ar(l,r) -> (get_param_type q r)
          | _ -> failwith ("Type of non-terminal "^nt^" does not match with the number of specified parameters.")
        in 
        get_param_type parms (nonterminal_type rs nt)
   with Not_found -> failwith ("get_parameter_type: formal parameter '"^x^"' not used in the recursion scheme.")
;;

(** Long normal form (lnf) **)

(* For the creation of fresh variables *)
let freshvar = ref 0;;
let new_freshvar() = incr(freshvar); "#"^(string_of_int !freshvar) ;;

(** [rule_to_lnf rs rule] converts a grammar rule into LNF
   @param rs is the recursion scheme
   @param rule is the rule to be converted
   @return lnfrule,var_to_types 
    where [lnfrule] is the rule in LNF,
    and [var_to_types] is an association list mapping variable (i.e. the parameters of the rule) to their type
    (possibly containing new fresh variables introduced during the eta-expansion
**)
let rule_to_lnf rs (nt,param,rhs) = 
  (* create the association list mapping parameters' name to their type *)
  let fvtypes = create_param_typ_list param (nonterminal_type rs nt) in
  let newvarstypes = ref [] in
  let rec lnf appterm = lnf_aux (appterm_type rs fvtypes appterm) appterm
  and lnf_aux typ appterm =     
    (* decompose the term in the form e_0 e_1 ... e_k *)
    let op,operands = applicative_decomposition appterm in
    (* Create a list of fresh variables Phi_1 ... Phi_n where n is the arity of appterm *)
    let absvars = Array.to_list (Array.init (typearity typ) (fun i -> new_freshvar()) ) in
    (* create an association list mapping Phi_1 ... Phi_n to their respective types *)
    let absvars_types = create_param_typ_list absvars typ
    (* compute the lnfs of the operands *)
    and lnfoperands = List.map lnf operands in
    (* add 'lnf(Phi_1) ... lnf(Phi_n)'  to the list of operands *)    
    let lnfoperands_ext = lnfoperands@(List.map (function (v,t) -> lnf_aux t (Var(v))) absvars_types) in
      newvarstypes := !newvarstypes@absvars_types; (* accumulates the list of created fresh variables *)
      match op with
          Tm(t)  -> absvars, LnfAppTm(t, lnfoperands_ext)
	    | Var(v) -> absvars, LnfAppVar(v, lnfoperands_ext)
	    | Nt(nt) -> absvars, LnfAppNt(nt, lnfoperands_ext)
	    | App(_) -> (* this cannot be reached *)
	                failwith "eq_to_lnf: the operator calculated by applicative_decomposition is inconsistent!"
  in  
    (nt, (param, (snd (lnf rhs)))),(* the first componebt of the pair returned by 'lnf rhs' 
                                      (the list of abstracted variables)  is necessarily 
                                      empty since the rhs of the rule is of order 0 *) 
    fvtypes@(!newvarstypes)  (* the association list mapping variables to their type *)
;;

(** Convert a recscheme to lnf.
    @return (lnfrules,vartm_types) where 
    [lnfrules] is a list of rules in lnf and
    [vartm_types] is an association list mapping variables (i.e. parameters of the rules) 
                  and terminal names to their type. **)
let rs_to_lnf rs = 
  let vartypes = ref [] in
  freshvar := 0; (* reinit the counter for the creation of fresh variables *)
  (List.map (function rule -> let lnfrule,newvtypes = rule_to_lnf rs rule in
                              vartypes := !vartypes@newvtypes;
                              lnfrule ) rs.rules
  ) , !vartypes@rs.sigma
;;





(**************** Validators ***********)

exception InvalidPath of string;;


(** Validator for paths of Urzyczyn's tree based on De Mirand's decomposition. *)
let demiranda_validator path =
   let s = Array.of_list path in
   let f = ref 0 in
   let b = ref ((Array.length s)-1) in
   let read_forward ident = if s.(!f) = ident then incr(f) else raise (InvalidPath "unexpected terminal symbol") in
   let read_backward ident = if s.(!b) = ident then decr(b) else raise (InvalidPath "unexpected terminal symbol") in
   (* A function that checks for a prefix of a well-bracketed sequence starting at !f and finishing at e.
      It returns (lev,nopen) where level is the nesting level (0 for a well-bracketed sequence) at !f
      and nopen is the number of occurrences of the opening bracket '['. *)
   let well_bracketed_prefix e =
     let level = ref 0 in
     let nopen = ref 0 in
     while !f <= e do
       (match s.(!f) with
         "[" -> incr nopen; incr level
        | "]" when !level > 0 -> decr level;
        | _ -> raise (InvalidPath "unexpected terminal symbol"));
        incr f;
        if !f < e then read_forward "3";                                                       
     done;
     !level,!nopen
   in
   (* a function that checks read the longest well-bracketed sequence ending
      at b *)
   let read_backward_longest_well_bracketed () =
     let level = ref 0 and cont = ref true in
     while !cont && !b >= 0 do
       (match s.(!b) with
         "]" -> incr level;
                read_backward "]";
                if !b > 0 then read_backward "3";
        | "[" when !level >0 -> decr level;
                                read_backward "[";
                                if !b > 0 then read_backward "3";
        | "[" -> cont:= false;
        | _ -> raise (InvalidPath "unexpected terminal symbol") );
     done;
     (* If the whole sequence has been read then it must be completely well-bracketed *)
     if !cont && !level <> 0 then
       raise (InvalidPath "not a prefix of a well-bracketed sequence.") 
   in
   (* Check de Miranda's decomposition of the Urzyczin word. 
      returns nstars,nopen where nstars is the number of stars at the end of the sequence,
      and nopen is the number of opening brackets in the first part of the 
      de Miranda's decomposition. *)
   let demiranda_decompos() =
        (* We first proceed by reading the sequence backwards: *)
        (* 1 - counts the number of stars at the end of the sequence  *)
        let nbstars = ref 0 in
        while s.(!b) = "*" do 
        read_backward "*";
        incr nbstars;                                                               
        done;
        read_backward "3";
        (* 2 - read backwards the longest well-bracketed sequence *)
        read_backward_longest_well_bracketed();

        (* 3 - read forwards the remaining part of the sequence (the beginning), checking
        that it is a prefix of a well-bracketed sequence and counting the number of 
        occurrences of opening bracket '['. *)
        let level,nbopening = well_bracketed_prefix !b in
        
        !nbstars,nbopening
    in
    
    let path_text = String.concat " " path in
    
    (* accepts the empty string *)
    if !b = -1 then true,("Empty path: "^path_text)
    else
        try                                                         
           match s.(!b) with
            "e" -> decr b; (* skip the 'e' at the end *)
                   let nbstars,nbopening = demiranda_decompos() in
                   (* Check that the number of star is equal to the number of '[' *)
                   if nbstars = nbopening then
                     true,("Valid maximal path: "^path_text)
                   else
                     false,("Invalid maximal path: "^path_text)

            | "r" ->  (* Check for a well-bracketed sequence from !f to !b-1 *)
                      if fst (well_bracketed_prefix (!b-1)) = 0 then
                        true,("Valid maximal path: "^path_text)
                      else
                        false,("Invalid maximal path: "^path_text)

            | "[" | "]" -> ignore(well_bracketed_prefix !b); true,("Valid prefix path: "^path_text)

            | "3" -> ignore(well_bracketed_prefix (!b-1)); true,("Valid prefix path: "^path_text)
            
            | "*" -> let nbstars,nbopening = demiranda_decompos() in
                     (* Check that the number of star is <= than the number of '[' *)
                     if nbstars <= nbopening then
                       true,("Valid prefix path: "^path_text)
                     else
                       false,("Invalid prefix path: "^path_text)
                       
            | _ -> false,("Invalid path containing undefined terminals: "^path_text)
        with InvalidPath(msg) -> false, ("Invalid path, "^msg^": "^path_text)
;;

let default_validator path =  
    true, (String.concat " " path)
;;

let reverse_demiranda_validator path = 
    true, "Reversed path:"^(String.concat " " (List.rev path))

;;



(**** Tests **)

(*

(* example of recursion scheme *)
let rs : recscheme = {
  nonterminals = [ "S", Gr;
                   "F", Ar(Gr,Ar(Gr,Gr)) ;
                   "G", Ar(Ar(Gr,Gr),Ar(Gr,Gr)) ];
  sigma = [ "f", Ar(Gr,Ar(Gr,Gr));
            "g", Ar(Gr,Gr);
            "t", Ar(Gr,Ar(Gr,Gr)) ;
            "e", Gr ];
  rules = [ "S",[],App(App(Tm("f"), Tm("e")),Tm("e"));
            "F",["x";"y"],App(App(Tm("f"), Var("x")), Var("y"));
            "G",["phi";"x"],App(Tm("g"), App(Tm("g"), Var("x")));
          ]
} ;;

string_of_type (Ar(Gr,Ar(Gr,Gr)));;
print_alphabet rs.sigma;;
print_rs rs;;
rs_check rs;;
oi_derivation rs;


(* HORS producing Urzyczyn's tree *)
let urz = {
    nonterminals = [ "S", Gr;
                     "D", Ar(Ar(Gr,Ar(Gr,Gr)), Ar(Gr,Ar(Gr,Ar(Gr,Gr)))) ;
                     "F", Ar(Gr,Gr) ;
                     "E", Gr ;
                     "G", Ar(Gr,Ar(Gr,Gr)) ;
                   ];
    sigma = [   "[", Ar(Gr,Gr) ;
                "]", Ar(Gr,Gr);
                "*", Ar(Gr,Gr);
                "3", Ar(Gr,Ar(Gr,Ar(Gr,Gr)));
                "e", Gr;
                "r", Gr;
            ];
    rules = [   "S",[],App(Tm("["),
                     App(App(App(App(Nt("D"), Nt("G")),Nt("E")),Nt("E")),Nt("E"))
                     ); 
                "D",["phi";"x";"y";"z"],
                    App(App(App(Tm("3"),
                        App(Tm("["), 
                        App(App(App(App(Nt("D"), App(App(Nt("D"), Var("phi")),Var("x"))),
                        Var("z")
                        ),
                        App(Nt("F"), Var("y"))
                        ),App(Nt("F"), Var("y")))
                        )),
                        App(Tm("]"), App(App(Var("phi"),Var("y")),Var("x")))),
                        App(Tm("*"), Var("z")));
                "F",["x"],App(Tm("*"),Var("x"));
                "E",[],Tm("e");
                "G",["u";"v"],Tm("r");
        ];
        
    rs_path_validator = Hog.demiranda_validator
 };;


*)