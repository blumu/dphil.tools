# by William Blum
# Version of 05/12/2007

OMakeVersion(0.9.8.5, 0.9.8.5)

open Dotnet


if $(defined WITHMONO)
    public.CSCFLAGS=-noconfig -nowarn:1701,1702  -warn:4 
    if $(defined DEBUG)
        CSCFLAGS+=-define:DEBUG -define:TRACE -debug+ -debug:full -optimize- 
        export
    else
        CSCFLAGS+=-define:TRACE -debug:pdbonly -optimize+ 
        export
    public.RESGENFLAGS=
    export
else
    public.CSCFLAGS=/noconfig /nowarn:1701,1702 /errorreport:prompt /warn:4 
    if $(defined DEBUG)
        CSCFLAGS+=/define:DEBUG /define:TRACE /debug+ /debug:full /optimize- 
        export
    else
        CSCFLAGS+=/define:TRACE /debug:pdbonly /optimize+ 
        export
    public.RESGENFLAGS=
    export

        
# returns the output path for a given output filename  
public.OUTPUT(name) =
    return(/out:$(file $(name)))
    

public.TARGET_LIBRARY=/target:library


############### Resources

# Compile a .resx file into a .resources file with the namespace naming conventing
# (e.g. a resource with relative path subdir\file.resx in an assembly named 'Assembly' 
#   will be compiled into Assembly.subdir.file.resources)
# Parameters
#   modulename is the name of the .net assembly
#   relpath is the relative path to the resource file without the .resx extension
# Return
#   the name of the output file without the extension (e.g. Assembly.subdir.file)
#
public.NamespacedDotnetResource(modulename, relpath) =
    protected.splitpath = $(split /, $(relpath))
    protected.output=$(modulename).$(concat ., $(splitpath))
    $(output).resources: $(relpath).resx
        $(RESGEN) /useSourcePath $(RESGEN_FLAGS) $< $@

    return $(output)


%.resources: %.resx
    $(RESGEN) $(RESGEN_FLAGS) $<






        
#### To build an .exe .net assembly
####
# Parameters:
#  name
#  files
# Additional variables used:
#  CSHARP_INCLUDEPATH
#  CSHARP_OTHER_DLLREFS
#  CSHARP_DLLREFS
#  CSHARP_RESOURCES
#  CSCFLAGS
public.CSharpDllAssembly(name, files) =  
    protected.RCFILES =$(addsuffix .resources, $(CSHARP_RESOURCES))
    protected.OTHER_DLLS =$(addsuffix .dll, $(CSHARP_OTHER_DLLREFS))
    protected.DEP_DLLS = $(addprefix $(OUTPUTDIR)/, $(addsuffix .dll, $(CSHARP_DLLREFS)))

    protected.name = $(file $(name))
    protected.DLLASM = $(file $(OUTPUTDIR)/$(name)$(EXT_DLL))

    if $(defined FORMONO)
        foreach(res, $(CSHARP_RESOURCES))
            RCFILES+="$(res)+$(res).resources"
            export
        export

    #
    # Rules to build byte-code and native targets
    #
    # Create additionnal dummy resource files (this is necessary to overcome a bug in Mono)
    foreach(res, $(CSHARP_RESOURCES))
        $(res)+$(res).resx: $(res).resx
            cp $(res).resx "$(res)+$(res).resx"
    
    $(DLLASM): $(RCFILES) $(files) $(DEP_DLLS)
        @echo "- C# compilation..."
        $(CSC) $(CSCFLAGS) \
                $(addprefix /lib:, $(CSHARP_INCLUDEPATH)) $(addprefix /reference:, $(OTHER_DLLS)) $(addprefix /reference:,$(DEP_DLLS)) \
                $(addprefix /resource:,$(RCFILES)) \
                $(TARGET_LIBRARY) $(OUTPUT $@) $(files)
        @echo "***********************************************************" \
        && echo "The assembly $(DLLASM) has been created successfuly" \
        && echo "***********************************************************"


    return $(DLLASM) 
   
